<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="lemoon.can.milkyway.infrastructure.repository.mapper.ChatMapper">
    <update id="update" parameterType="lemoon.can.milkyway.infrastructure.repository.dos.ChatDO">
        UPDATE chat
        <set>
            <!-- 如果 title 不为 null，更新 title 字段 -->
            <if test="title != null">
                title = #{title},
            </if>
            <!-- 如果 bulletin 不为 null，更新 bulletin 字段 -->
            <if test="bulletin != null">
                bulletin = #{bulletin},
            </if>
        </set>
        WHERE id = #{id}
    </update>

    <select id="findSingleChat" resultType="lemoon.can.milkyway.infrastructure.repository.dos.ChatInfoDO">
        select
            c.id,
            c.type as chat_type,
            coalesce(f.remark, fu.nick_name) as title,
            fu.avatar as avatar,
            fu.id as friend_id,
            lm.id as last_message_id,
            lm.type as last_message_type,
            lm.content as last_message,
            lm.sent_time as last_message_time,
            unread_info.count as unread_count,
            unread_info.min_msg_id as min_unread_message_id,
            fu.online as online
        from chat c
        -- 双方都在该会话中
        join chat_member cm1 on cm1.chat_id = c.id and cm1.user_id = #{userId}
        join chat_member cm2 on cm2.chat_id = c.id and cm2.user_id = #{friendUserId}
        join users fu on fu.id = #{friendUserId}
        left join friend f on f.user_id = #{userId} and f.friend_id = fu.id
        -- 最后一条消息
        left join message lm on lm.id = (select m2.id
                                         from message m2
                                         where m2.chat_id = c.id order by m2.id desc limit 1)
        -- 未读统计
        left join (select mcount.chat_id, count(*) as count,min(mcount.id) as min_msg_id
                   from message mcount
                       join message_read_cursor mrc on mrc.chat_id = mcount.chat_id and mrc.user_id = #{userId}
                   where mcount.id > coalesce(mrc.last_read_message_id, 0) and mcount.sender_id != #{userId}
                   group by mcount.chat_id)
            as unread_info on unread_info.chat_id = c.id
        where c.type = 'single';
    </select>

    <select id="findGroupChats" resultType="java.lang.Long">
        select c.id
        from chat_member cm
        join chat c on cm.chat_id = c.id
        where cm.user_id = #{user_id} and c.type='GROUP';
    </select>

    <!-- 游标分页查询聊天列表 - 最终优化版本 -->
    <select id="findChatsByUserId" resultType="lemoon.can.milkyway.infrastructure.repository.dos.ChatInfoDO">
        SELECT
        c.id, -- 会话 ID
        c.type AS chatType, -- 会话类型：SINGLE 或 GROUP

        -- 会话标题：单聊优先显示朋友备注、其次昵称，群聊显示群名称
        CASE
        WHEN c.type = 'SINGLE' THEN
        COALESCE(f.remark, u_friend.nick_name)
        ELSE
        c.title
        END AS title,

        -- 会话头像：群取 extra_info 里的 group_avator，单聊取对方头像
        CASE
        WHEN c.type = 'GROUP' THEN
        JSON_UNQUOTE(JSON_EXTRACT(c.extra_info, '$.group_avator'))
        ELSE
        u_friend.avatar
        END AS avatar,

        -- 好友ID：仅适用于单聊
        IF(c.type = 'SINGLE', u_friend.id, NULL) AS friendId,

        lm.id AS lastMessageId,
        lm.type as lastMessageType,
        -- 最后一条消息内容（来自预处理子查询 lm）
        lm.content AS lastMessage,

        -- 最后一条消息时间
        lm.sent_time AS lastMessageTime,

        -- 未读数：统计当前用户在该聊天中未读的消息数量
        COALESCE(unread.unreadCount, 0) AS unreadCount,

        -- 最小未读消息ID
        unread.minUnreadMessageId AS minUnreadMessageId,

        -- 在线状态：仅对 SINGLE 会话展示，GROUP 永远为 false
        CASE
        WHEN c.type = 'SINGLE' THEN COALESCE(u_friend.online, false)
        ELSE false
        END AS online

        FROM chat_member cm
        JOIN chat c ON cm.chat_id = c.id

        -- 对方 chat_member，仅适用于 SINGLE 聊天（排除自己）
        LEFT JOIN chat_member cm_friend ON (
        cm_friend.chat_id = c.id
        AND cm_friend.user_id != #{userId}
        AND c.type = 'SINGLE'
        )

        -- 对方用户信息（SINGLE 聊天用）
        LEFT JOIN users u_friend ON (
        u_friend.id = cm_friend.user_id
        )

        -- 朋友关系信息（获取备注）
        LEFT JOIN friend f ON (
        f.user_id = #{userId}
        AND f.friend_id = cm_friend.user_id
        AND c.type = 'SINGLE'
        )

        -- 最后一条消息子查询（提升性能，避免重复查询）
        LEFT JOIN (
        SELECT t.*
            FROM (
                SELECT m.id, m.chat_id, m.type, m.content, m.sent_time,
                ROW_NUMBER() OVER (PARTITION BY chat_id ORDER BY id DESC) AS rn
                FROM message m
                ) t WHERE rn = 1
        ) lm ON lm.chat_id = c.id

        -- 未读消息数和最小未读消息ID子查询
        LEFT JOIN (
        SELECT
        m.chat_id,
        COUNT(*) AS unreadCount,
        MIN(m.id) AS minUnreadMessageId
        FROM message m
        LEFT JOIN message_read_cursor mrc ON m.chat_id = mrc.chat_id AND mrc.user_id = #{userId}
        WHERE m.id > COALESCE(mrc.last_read_message_id, 0)
        AND m.sender_id != #{userId}
        GROUP BY m.chat_id
        ) unread ON unread.chat_id = c.id

        -- 当前用户参与的会话
        WHERE cm.user_id = #{userId}

        -- 分页：只查询 ID 小于 lastMessageId 的记录（用于向下翻页）
        <if test="lastMessageId != null">
            AND lm.id &lt; #{lastMessageId}
        </if>

        -- 排序：先按消息ID，再按会话 ID
        ORDER BY lm.id DESC

        -- 分页大小限制
        LIMIT #{pageSize}
    </select>

    <select id="selectChatInfoById" resultType="lemoon.can.milkyway.infrastructure.repository.dos.ChatInfoDO">
        select c.id,
               c.type as chat_type,
               c.title,
               m.id as last_message_id,
               m.type as last_message_type,
               m.content as last_message,
               m.sent_time as last_message_time
        from chat c
        join message m on c.id = m.chat_id
        where c.id = #{id}
    </select>
</mapper>